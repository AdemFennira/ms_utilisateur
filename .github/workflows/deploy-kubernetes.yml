name: Déploiement Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: "Environnement cible (integration/production)"
        required: true
        type: string
      namespace:
        description: "Namespace Kubernetes"
        required: true
        type: string
      microservice-name:
        description: "Nom du microservice"
        required: true
        type: string
      image-tag:
        description: "Tag de l'image Docker"
        required: true
        type: string
    secrets:
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_KUBECONFIG:
        required: true
      OCI_CLI_USER:
        required: false
      OCI_CLI_FINGERPRINT:
        required: false
      OCI_CLI_TENANCY:
        required: false
      OCI_CLI_REGION:
        required: false
      OCI_CLI_KEY_CONTENT:
        required: false
      MYSQL_HOST:
        required: false
      MYSQL_USER:
        required: false
      MYSQL_PASSWORD:
        required: false
      MYSQL_ROOT_PASSWORD:
        required: false

env:
  OCI_REGION: eu-paris-1
  OCI_REGISTRY: cdg.ocir.io

jobs:
  deploy:
    name: Déployer sur ${{ inputs.environment }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4


      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Install OCI CLI
        run: |
          echo "Installation d'OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install-oci-cli.sh
          bash install-oci-cli.sh --accept-all-defaults
          
          # Ajouter au PATH pour les prochains steps
          echo "$HOME/bin" >> $GITHUB_PATH
          
          # Export pour ce step
          export PATH="$HOME/bin:$PATH"
          
          # Vérifier l'installation
          oci --version
          
          echo "✅ OCI CLI installé"

      - name: Configure OCI CLI
        env:
          OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
          OCI_CLI_FINGERPRINT: ${{ secrets.OCI_CLI_FINGERPRINT }}
          OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}
          OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION }}
          OCI_CLI_KEY_CONTENT: ${{ secrets.OCI_CLI_KEY_CONTENT }}
        run: |
          if [ -z "$OCI_CLI_USER" ]; then
            echo "⚠️  OCI_CLI_USER non défini, configuration OCI CLI ignorée"
            echo "Le kubeconfig doit utiliser un token au lieu d'exec plugin"
            exit 0
          fi
          
          echo "Configuration d'OCI CLI..."
          mkdir -p ~/.oci
          chmod 700 ~/.oci
          
          # Créer le fichier de configuration
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=$OCI_CLI_USER
          fingerprint=$OCI_CLI_FINGERPRINT
          tenancy=$OCI_CLI_TENANCY
          region=$OCI_CLI_REGION
          key_file=~/.oci/oci_api_key.pem
          EOF
          
          chmod 600 ~/.oci/config
          
          # Créer la clé privée
          echo "$OCI_CLI_KEY_CONTENT" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          
          echo "✅ OCI CLI configuré"

      - name: Configure OKE Kubernetes context
        env:
          OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          
          # Vérifier si le kubeconfig utilise exec plugin
          if grep -q "exec:" ~/.kube/config && grep -q "oci" ~/.kube/config; then
            echo "⚠️  Le kubeconfig utilise l'exec plugin OCI CLI"
            
            if [ -z "$OCI_CLI_USER" ]; then
              echo ""
              echo "╔═══════════════════════════════════════════════════════════════════════════╗"
              echo "║  ❌ ERREUR: OCI CLI non configuré                                         ║"
              echo "╚═══════════════════════════════════════════════════════════════════════════╝"
              echo ""
              echo "Le kubeconfig utilise l'exec plugin OCI qui nécessite une configuration"
              echo "OCI CLI complète avec API keys."
              echo ""
              echo "SOLUTION: Créez ces 5 secrets dans GitHub:"
              echo "  https://github.com/${{ github.repository }}/settings/secrets/actions"
              echo ""
              echo "  1. OCI_CLI_USER          - OCID de votre utilisateur OCI"
              echo "  2. OCI_CLI_FINGERPRINT   - Fingerprint de votre API key"
              echo "  3. OCI_CLI_TENANCY       - OCID de votre tenancy"
              echo "  4. OCI_CLI_REGION        - Région (eu-paris-1)"
              echo "  5. OCI_CLI_KEY_CONTENT   - Contenu complet de votre clé privée .pem"
              echo ""
              echo "Pour obtenir ces valeurs, dans OCI Cloud Shell:"
              echo "  cat ~/.oci/config"
              echo "  cat ~/.oci/oci_api_key.pem"
              echo ""
              echo "Voir le fichier VOS_VALEURS_SECRETS_GITHUB.txt dans le repo pour vos valeurs."
              echo ""
              exit 1
            fi
            
            echo "✅ OCI CLI est configuré, l'exec plugin devrait fonctionner"
          else
            echo "✅ Le kubeconfig utilise un token (pas d'exec plugin)"
          fi
          
          echo ""
          echo "Vérification de la connexion au cluster..."
          if ! kubectl cluster-info; then
            echo ""
            echo "❌ Échec de connexion au cluster Kubernetes"
            echo ""
            echo "Vérifiez:"
            echo "  1. Le secret OCI_KUBECONFIG est-il correctement encodé en base64?"
            echo "  2. Si le kubeconfig utilise exec plugin, OCI CLI est-il configuré?"
            echo "  3. Le cluster OKE est-il accessible?"
            echo ""
            exit 1
          fi
          
          echo ""
          echo "✅ Connexion au cluster réussie"
          echo ""
          kubectl get nodes

      - name: Créer le namespace si nécessaire
        run: |
          kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace ${{ inputs.namespace }} environment=${{ inputs.environment }} --overwrite

      - name: Créer le Secret pour OCIR
        run: |
          echo "Configuration du secret OCIR pour Kubernetes..."
          
          # Construire le username complet si nécessaire
          OCI_USERNAME="${{ secrets.OCI_USERNAME }}"
          OCI_TENANCY_NAMESPACE="${{ secrets.OCI_TENANCY_NAMESPACE }}"
          
          # Si l'username ne contient pas le tenancy namespace, on l'ajoute
          if [[ "$OCI_USERNAME" != *"/"* ]]; then
            FULL_USERNAME="${OCI_TENANCY_NAMESPACE}/${OCI_USERNAME}"
            echo "⚠️  Username modifié pour inclure le tenancy: $FULL_USERNAME"
          else
            FULL_USERNAME="$OCI_USERNAME"
            echo "✅ Username déjà au bon format: $FULL_USERNAME"
          fi
          
          # Créer le secret Docker Registry
          kubectl create secret docker-registry ocir-secret \
            --docker-server=${{ env.OCI_REGISTRY }} \
            --docker-username="$FULL_USERNAME" \
            --docker-password="${{ secrets.OCI_AUTH_TOKEN }}" \
            --namespace=${{ inputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ Secret OCIR créé dans le namespace ${{ inputs.namespace }}"

      - name: Créer les secrets MySQL
        run: |
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace=${{ inputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ Secrets MySQL créés dans le namespace ${{ inputs.namespace }}"

      - name: Créer les ConfigMaps
        run: |
          if [ "${{ inputs.environment }}" == "production" ]; then
            SPRING_PROFILE="production"
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          else
            SPRING_PROFILE="integration"
            LOG_LEVEL="DEBUG"
            LOG_LEVEL_JDBC="DEBUG"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE=${SPRING_PROFILE} \
            --from-literal=LOG_LEVEL=${LOG_LEVEL} \
            --from-literal=LOG_LEVEL_JDBC=${LOG_LEVEL_JDBC} \
            --namespace=${{ inputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ ConfigMap créée dans le namespace ${{ inputs.namespace }}"

      - name: Préparer et déployer l'application
        run: |
          TENANCY_NAMESPACE="${{ secrets.OCI_TENANCY_NAMESPACE }}"
          IMAGE_REPO="${{ env.OCI_REGISTRY }}/${TENANCY_NAMESPACE}/smartdish/${{ inputs.microservice-name }}"
          IMAGE_TAG="${{ inputs.image-tag }}"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            REPLICAS=2
          else
            REPLICAS=1
          fi
          
          echo "Configuration du déploiement:"
          echo "  Microservice: ${{ inputs.microservice-name }}"
          echo "  Namespace: ${{ inputs.namespace }}"
          echo "  Image: ${IMAGE_REPO}:${IMAGE_TAG}"
          echo "  Replicas: ${REPLICAS}"
          
          # Substituer les variables dans le template
          sed -e "s|\${MICROSERVICE_NAME}|${{ inputs.microservice-name }}|g" \
              -e "s|\${NAMESPACE}|${{ inputs.namespace }}|g" \
              -e "s|\${VERSION}|${IMAGE_TAG}|g" \
              -e "s|\${REPLICAS}|${REPLICAS}|g" \
              -e "s|\${IMAGE_URL}|${IMAGE_REPO}|g" \
              -e "s|\${IMAGE_TAG}|${IMAGE_TAG}|g" \
              k8s/oci/deployment-template.yaml > /tmp/deployment.yaml
          
          echo ""
          echo "Fichier de déploiement généré:"
          cat /tmp/deployment.yaml
          echo ""
          
          # Appliquer le déploiement
          kubectl apply -f /tmp/deployment.yaml
          
          echo "✅ Déploiement appliqué"

      - name: Vérifier le déploiement
        run: |
          echo "Attente du déploiement..."
          kubectl rollout status deployment/${{ inputs.microservice-name }} -n ${{ inputs.namespace }} --timeout=5m
          
          echo ""
          echo "Pods en cours d'exécution:"
          kubectl get pods -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }}
          
          echo ""
          echo "Services:"
          kubectl get svc -n ${{ inputs.namespace }} -l app=${{ inputs.microservice-name }}
          
          echo ""
          echo "✅ Déploiement réussi!"
