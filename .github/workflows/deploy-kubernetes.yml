name: CD - Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        type: string
      microservice-name:
        description: 'Microservice name'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag'
        required: true
        type: string
    secrets:
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_KUBECONFIG:
        required: true
      OKE_CLUSTER_ID:
        required: true
      OCI_CLI_USER:
        required: false
      OCI_CLI_FINGERPRINT:
        required: false
      OCI_CLI_TENANCY:
        required: false
      OCI_CLI_REGION:
        required: false
      OCI_CLI_KEY_CONTENT:
        required: false
      MYSQL_HOST:
        required: true
      MYSQL_USER:
        required: true
      MYSQL_PASSWORD:
        required: true
      MYSQL_ROOT_PASSWORD:
        required: true
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - integration
          - production
        default: integration
      image-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      NAMESPACE: ${{ inputs.namespace }}
      MICROSERVICE_NAME: ${{ inputs.microservice-name }}
      IMAGE_TAG: ${{ inputs.image-tag }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION || 'eu-paris-1' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install OCI CLI
        run: |
          echo "Installation d'OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "‚úÖ OCI CLI install√©"

      - name: Configure OCI CLI
        run: |
          echo "Configuration d'OCI CLI..."
          
          # Cr√©er le r√©pertoire de configuration
          mkdir -p ~/.oci
          
          # √âcrire la cl√© priv√©e (pr√©server les retours √† la ligne)
          echo "${{ secrets.OCI_CLI_KEY_CONTENT }}" > ~/.oci/oci_api_key.pem
          
          # V√©rification du format de la cl√©
          if ! grep -q "BEGIN RSA PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide"
            echo "La cl√© doit commencer par '-----BEGIN RSA PRIVATE KEY-----'"
            exit 1
          fi
          
          if ! grep -q "END RSA PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide"
            echo "La cl√© doit se terminer par '-----END RSA PRIVATE KEY-----'"
            exit 1
          fi
          
          # Permissions strictes (obligatoire pour OCI)
          chmod 600 ~/.oci/oci_api_key.pem
          
          # Cr√©er le fichier de configuration OCI
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=${{ secrets.OCI_CLI_USER }}
          fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_CLI_TENANCY }}
          region=${{ env.OCI_CLI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          EOF
          
          # Permissions pour le fichier de config
          chmod 600 ~/.oci/config
          
          echo "‚úÖ Configuration OCI cr√©√©e"
          
          # Afficher la config (sans donn√©es sensibles)
          echo "Configuration OCI (masqu√©e) :"
          echo "- User: ${OCI_CLI_USER:0:20}..."
          echo "- Tenancy: ${OCI_CLI_TENANCY:0:20}..."
          echo "- Region: ${{ env.OCI_CLI_REGION }}"
        env:
          OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
          OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}

      - name: Test OCI CLI Connection
        run: |
          echo "Test de la connexion OCI..."
          
          # Test avec timeout
          timeout 30s oci iam region list --query "data[0].name" --raw-output || {
            echo "‚ùå √âchec du test de connexion OCI"
            echo ""
            echo "üîç V√©rifications n√©cessaires :"
            echo "1. OCI_CLI_USER : OCID de l'utilisateur"
            echo "2. OCI_CLI_FINGERPRINT : Fingerprint de la cl√© API"
            echo "3. OCI_CLI_TENANCY : OCID du tenancy"
            echo "4. OCI_CLI_REGION : R√©gion OCI (ex: eu-frankfurt-1)"
            echo "5. OCI_API_KEY : Cl√© priv√©e au format PEM avec retours √† la ligne"
            echo ""
            echo "üìö Documentation :"
            echo "https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm"
            exit 1
          }
          
          echo "‚úÖ Connexion OCI √©tablie avec succ√®s"

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          # Cr√©er le kubeconfig avec OCI CLI
          mkdir -p ~/.kube
          
          oci ce cluster create-kubeconfig \
            --cluster-id "${{ secrets.OKE_CLUSTER_ID }}" \
            --file ~/.kube/config \
            --region "${{ env.OCI_CLI_REGION }}" \
            --token-version 2.0.0 \
            --kube-endpoint PUBLIC_ENDPOINT
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√©"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          echo "V√©rification du namespace '${{ env.NAMESPACE }}'..."
          
          if kubectl get namespace "${{ env.NAMESPACE }}" &> /dev/null; then
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '${{ env.NAMESPACE }}'..."
            kubectl create namespace "${{ env.NAMESPACE }}"
            kubectl label namespace "${{ env.NAMESPACE }}" environment=${{ inputs.environment }}
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' cr√©√©"
          fi

      - name: Create or Update Secrets
        run: |
          echo "Configuration des secrets..."
          
          # Secret OCIR
          kubectl create secret docker-registry ocir-secret \
            --docker-server=cdg.ocir.io \
            --docker-username="${{ secrets.OCI_TENANCY_NAMESPACE }}/${{ secrets.OCI_USERNAME }}" \
            --docker-password="${{ secrets.OCI_AUTH_TOKEN }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secret OCIR configur√©"
          
          # Secret MySQL
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets MySQL configur√©s"

      - name: Create or Update ConfigMap
        run: |
          echo "Configuration de la ConfigMap..."
          
          SPRING_PROFILE="${{ inputs.environment }}"
          LOG_LEVEL="DEBUG"
          LOG_LEVEL_JDBC="DEBUG"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE="$SPRING_PROFILE" \
            --from-literal=LOG_LEVEL="$LOG_LEVEL" \
            --from-literal=LOG_LEVEL_JDBC="$LOG_LEVEL_JDBC" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap configur√©e"

      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Variables pour le template
          export MICROSERVICE_NAME="${{ env.MICROSERVICE_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export VERSION="${{ env.IMAGE_TAG }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          export IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}"
          
          # D√©terminer le nombre de replicas selon l'environnement
          if [ "${{ inputs.environment }}" == "production" ]; then
            export REPLICAS=2
          else
            export REPLICAS=1
          fi
          
          echo "Configuration du d√©ploiement:"
          echo "  - Microservice: $MICROSERVICE_NAME"
          echo "  - Namespace: $NAMESPACE"
          echo "  - Image: $IMAGE_URL:$IMAGE_TAG"
          echo "  - Replicas: $REPLICAS"
          
          # G√©n√©rer et appliquer le d√©ploiement
          envsubst < k8s/oci/deployment-template.yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          kubectl rollout status deployment/${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=50 || true
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment ${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç √âv√©nements r√©cents :"
            kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
            exit 1
          }
          
          echo "‚úÖ D√©ploiement r√©ussi"

      - name: Display Deployment Info
        run: |
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Microservice: ${{ env.MICROSERVICE_NAME }}"
          echo "üè∑Ô∏è  Image: cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "üåç Namespace: ${{ env.NAMESPACE }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üìù LOGS DES PODS (derni√®res 20 lignes)"
          echo "=========================================="
          kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=20 || true
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi