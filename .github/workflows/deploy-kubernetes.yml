name: CD - Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: true
        type: string
      microservice-name:
        description: 'Microservice name'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag'
        required: true
        type: string
    secrets:
      OCI_USERNAME:
        required: true
      OCI_AUTH_TOKEN:
        required: true
      OCI_TENANCY_NAMESPACE:
        required: true
      OCI_KUBECONFIG:
        required: true
      OKE_CLUSTER_ID:
        required: true
      OCI_CLI_USER:
        required: false
      OCI_CLI_FINGERPRINT:
        required: false
      OCI_CLI_TENANCY:
        required: false
      OCI_CLI_REGION:
        required: false
      OCI_API_KEY:
        required: false
      MYSQL_HOST:
        required: true
      MYSQL_USER:
        required: true
      MYSQL_PASSWORD:
        required: true
      MYSQL_ROOT_PASSWORD:
        required: true
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - integration
          - production
        default: integration
      image-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      NAMESPACE: ${{ inputs.namespace }}
      MICROSERVICE_NAME: ${{ inputs.microservice-name }}
      IMAGE_TAG: ${{ inputs.image-tag }}
      OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION || 'eu-paris-1' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install OCI CLI
        run: |
          echo "Installation d'OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "‚úÖ OCI CLI install√©"

      - name: Configure OCI CLI
        run: |
          echo "Configuration d'OCI CLI..."
          
          # Cr√©er le r√©pertoire de configuration
          mkdir -p ~/.oci
          
          # √âcrire la cl√© priv√©e avec gestion correcte des retours √† la ligne
          echo "$OCI_API_KEY" > ~/.oci/oci_api_key_raw.pem
          
          # V√©rifier le contenu initial
          echo "Taille de la cl√©: $(wc -c < ~/.oci/oci_api_key_raw.pem) bytes"
          echo "Nombre de lignes: $(wc -l < ~/.oci/oci_api_key_raw.pem)"
          
          # V√©rifier si la cl√© a les headers corrects
          if grep -q "BEGIN.*PRIVATE KEY" ~/.oci/oci_api_key_raw.pem; then
            echo "‚úÖ Format PEM avec headers d√©tect√©"
            cp ~/.oci/oci_api_key_raw.pem ~/.oci/oci_api_key.pem
          else
            echo "‚ö†Ô∏è  Cl√© sans headers d√©tect√©e, reconstruction du format PEM..."
            
            # D√©terminer le type de cl√© en fonction de la longueur ou du contenu
            # Par d√©faut, on utilise RSA PRIVATE KEY
            echo "-----BEGIN RSA PRIVATE KEY-----" > ~/.oci/oci_api_key.pem
            
            # Nettoyer et formater la cl√© (enlever les espaces, sauts de ligne superflus)
            cat ~/.oci/oci_api_key_raw.pem | tr -d '\n\r' | fold -w 64 >> ~/.oci/oci_api_key.pem
            
            echo "-----END RSA PRIVATE KEY-----" >> ~/.oci/oci_api_key.pem
            
            echo "‚úÖ Format PEM reconstruit"
          fi
          
          # V√©rification finale du format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide apr√®s reconstruction"
            echo ""
            echo "Premiers caract√®res du secret OCI_API_KEY:"
            head -c 100 ~/.oci/oci_api_key_raw.pem
            echo ""
            echo ""
            echo "üîß SOLUTION:"
            echo "Le secret OCI_API_KEY doit contenir votre cl√© priv√©e PEM COMPL√àTE, incluant:"
            echo "  -----BEGIN RSA PRIVATE KEY-----"
            echo "  [contenu encod√© en base64 sur plusieurs lignes]"
            echo "  -----END RSA PRIVATE KEY-----"
            echo ""
            echo "Pour obtenir la cl√©:"
            echo "1. OCI Console ‚Üí User Settings ‚Üí API Keys"
            echo "2. T√©l√©chargez la cl√© priv√©e (.pem)"
            echo "3. Copiez TOUT le contenu du fichier dans le secret GitHub"
            exit 1
          fi
          
          if ! grep -q "END.*PRIVATE KEY" ~/.oci/oci_api_key.pem; then
            echo "‚ùå Erreur: Format de cl√© OCI invalide - footer manquant"
            exit 1
          fi
          
          # Permissions strictes (obligatoire pour OCI)
          chmod 600 ~/.oci/oci_api_key.pem
          
          # Afficher les premi√®res et derni√®res lignes pour v√©rification
          echo "Format de la cl√© (premi√®re ligne):"
          head -n 1 ~/.oci/oci_api_key.pem
          echo "Format de la cl√© (derni√®re ligne):"
          tail -n 1 ~/.oci/oci_api_key.pem
          
          # Cr√©er le fichier de configuration OCI
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=${{ secrets.OCI_CLI_USER }}
          fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}
          tenancy=${{ secrets.OCI_CLI_TENANCY }}
          region=${{ env.OCI_CLI_REGION }}
          key_file=~/.oci/oci_api_key.pem
          EOF
          
          # Permissions pour le fichier de config
          chmod 600 ~/.oci/config
          
          echo "‚úÖ Configuration OCI cr√©√©e"
          
          # Afficher la config (sans donn√©es sensibles)
          echo "Configuration OCI (masqu√©e) :"
          echo "- User: ${OCI_CLI_USER:0:20}..."
          echo "- Tenancy: ${OCI_CLI_TENANCY:0:20}..."
          echo "- Region: ${{ env.OCI_CLI_REGION }}"
          echo "- Fingerprint: ${OCI_CLI_FINGERPRINT:0:14}..."
        env:
          OCI_API_KEY: ${{ secrets.OCI_API_KEY }}
          OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
          OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}
          OCI_CLI_FINGERPRINT: ${{ secrets.OCI_CLI_FINGERPRINT }}

      - name: Test OCI CLI Connection
        run: |
          echo "Test de la connexion OCI..."
          
          # D√©sactiver les prompts interactifs
          export OCI_CLI_SUPPRESS_FILE_PERMISSIONS_WARNING=True
          
          # Test avec timeout et sans prompt
          if timeout 30s oci iam region list --query "data[0].name" --raw-output 2>&1 | grep -q "passphrase"; then
            echo "‚ùå ERREUR: Votre cl√© priv√©e OCI est prot√©g√©e par un mot de passe (passphrase)"
            echo ""
            echo "üîß SOLUTION:"
            echo "Vous devez g√©n√©rer une nouvelle cl√© API SANS passphrase dans OCI Console:"
            echo ""
            echo "1. OCI Console ‚Üí User Settings ‚Üí API Keys"
            echo "2. Supprimez l'ancienne cl√© (celle avec passphrase)"
            echo "3. Cliquez sur 'Add API Key'"
            echo "4. S√©lectionnez 'Generate API Key Pair'"
            echo "5. ‚ö†Ô∏è  NE COCHEZ PAS 'Encrypt with passphrase'"
            echo "6. T√©l√©chargez la cl√© priv√©e (.pem)"
            echo "7. Notez le nouveau Fingerprint"
            echo "8. Mettez √† jour les secrets GitHub:"
            echo "   - OCI_API_KEY: Contenu du nouveau fichier .pem"
            echo "   - OCI_CLI_FINGERPRINT: Nouveau fingerprint"
            echo ""
            echo "‚ö†Ô∏è  Pour l'instant, on continue le d√©ploiement en utilisant le kubeconfig..."
            exit 0
          fi
          
          if timeout 30s oci iam region list --query "data[0].name" --raw-output 2>&1 | grep -E "error|Error|ERROR" > /dev/null; then
            echo "‚ö†Ô∏è  Avertissement: Test OCI CLI √©chou√©, mais on continue avec kubeconfig"
            echo "V√©rifiez vos secrets OCI si vous souhaitez utiliser OCI CLI:"
            echo "1. OCI_CLI_USER : OCID de l'utilisateur"
            echo "2. OCI_CLI_FINGERPRINT : Fingerprint de la cl√© API"
            echo "3. OCI_CLI_TENANCY : OCID du tenancy"
            echo "4. OCI_CLI_REGION : R√©gion OCI (ex: eu-paris-1)"
            echo "5. OCI_API_KEY : Cl√© priv√©e SANS passphrase"
            exit 0
          fi
          
          echo "‚úÖ Connexion OCI √©tablie avec succ√®s"

      - name: Setup Kubernetes Config
        run: |
          echo "Configuration de kubectl pour OKE..."
          
          mkdir -p ~/.kube
          
          # Utiliser directement le kubeconfig en base64 (ne n√©cessite pas OCI CLI)
          echo "${{ secrets.OCI_KUBECONFIG }}" | base64 -d > ~/.kube/config
          
          chmod 600 ~/.kube/config
          
          echo "‚úÖ Kubeconfig configur√© depuis le secret OCI_KUBECONFIG"
          
          # Afficher les informations du cluster (sans donn√©es sensibles)
          echo "Cluster endpoint: $(grep 'server:' ~/.kube/config | head -1 | awk '{print $2}')"

      - name: Verify Kubernetes Connection
        run: |
          echo "V√©rification de la connexion au cluster Kubernetes..."
          
          kubectl cluster-info || {
            echo "‚ùå Impossible de se connecter au cluster OKE"
            echo "V√©rifiez OKE_CLUSTER_ID dans les secrets GitHub"
            exit 1
          }
          
          kubectl get nodes
          
          echo "‚úÖ Connexion au cluster OKE √©tablie"

      - name: Create Namespace if not exists
        run: |
          echo "V√©rification du namespace '${{ env.NAMESPACE }}'..."
          
          if kubectl get namespace "${{ env.NAMESPACE }}" &> /dev/null; then
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' existe d√©j√†"
          else
            echo "Cr√©ation du namespace '${{ env.NAMESPACE }}'..."
            kubectl create namespace "${{ env.NAMESPACE }}"
            kubectl label namespace "${{ env.NAMESPACE }}" environment=${{ inputs.environment }}
            echo "‚úÖ Namespace '${{ env.NAMESPACE }}' cr√©√©"
          fi

      - name: Create or Update Secrets
        run: |
          echo "Configuration des secrets..."
          
          # Secret OCIR
          kubectl create secret docker-registry ocir-secret \
            --docker-server=cdg.ocir.io \
            --docker-username="${{ secrets.OCI_TENANCY_NAMESPACE }}/${{ secrets.OCI_USERNAME }}" \
            --docker-password="${{ secrets.OCI_AUTH_TOKEN }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secret OCIR configur√©"
          
          # Secret MySQL
          kubectl create secret generic mysql-secrets \
            --from-literal=MYSQL_HOST="${{ secrets.MYSQL_HOST }}" \
            --from-literal=MYSQL_PORT="3306" \
            --from-literal=MYSQL_DATABASE="smartdish" \
            --from-literal=MYSQL_USER="${{ secrets.MYSQL_USER }}" \
            --from-literal=MYSQL_PASSWORD="${{ secrets.MYSQL_PASSWORD }}" \
            --from-literal=MYSQL_ROOT_PASSWORD="${{ secrets.MYSQL_ROOT_PASSWORD }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets MySQL configur√©s"

      - name: Create or Update ConfigMap
        run: |
          echo "Configuration de la ConfigMap..."
          
          SPRING_PROFILE="${{ inputs.environment }}"
          LOG_LEVEL="DEBUG"
          LOG_LEVEL_JDBC="DEBUG"
          
          if [ "${{ inputs.environment }}" == "production" ]; then
            LOG_LEVEL="INFO"
            LOG_LEVEL_JDBC="WARN"
          fi
          
          kubectl create configmap app-config \
            --from-literal=SPRING_PROFILES_ACTIVE="$SPRING_PROFILE" \
            --from-literal=LOG_LEVEL="$LOG_LEVEL" \
            --from-literal=LOG_LEVEL_JDBC="$LOG_LEVEL_JDBC" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap configur√©e"

      - name: Apply Kubernetes Manifests
        run: |
          echo "D√©ploiement des manifests Kubernetes..."
          
          # Variables pour le template
          export MICROSERVICE_NAME="${{ env.MICROSERVICE_NAME }}"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export VERSION="${{ env.IMAGE_TAG }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          export IMAGE_URL="cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}"
          
          # D√©terminer le nombre de replicas selon l'environnement
          if [ "${{ inputs.environment }}" == "production" ]; then
            export REPLICAS=2
          else
            export REPLICAS=1
          fi
          
          echo "Configuration du d√©ploiement:"
          echo "  - Microservice: $MICROSERVICE_NAME"
          echo "  - Namespace: $NAMESPACE"
          echo "  - Image: $IMAGE_URL:$IMAGE_TAG"
          echo "  - Replicas: $REPLICAS"
          
          # G√©n√©rer et appliquer le d√©ploiement
          envsubst < k8s/oci/deployment-template.yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Manifests Kubernetes appliqu√©s"

      - name: Wait for Deployment Rollout
        run: |
          echo "Attente du d√©ploiement complet..."
          
          kubectl rollout status deployment/${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --timeout=5m || {
            echo "‚ùå Le d√©ploiement a √©chou√©"
            echo ""
            echo "üìã Logs des pods :"
            kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=50 || true
            echo ""
            echo "üìä √âtat des pods :"
            kubectl get pods -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç Description du d√©ploiement :"
            kubectl describe deployment ${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }}
            echo ""
            echo "üîç √âv√©nements r√©cents :"
            kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
            exit 1
          }
          
          echo "‚úÖ D√©ploiement r√©ussi"

      - name: Display Deployment Info
        run: |
          echo "=========================================="
          echo "üì¶ INFORMATIONS DE D√âPLOIEMENT"
          echo "=========================================="
          echo ""
          echo "üè∑Ô∏è  Microservice: ${{ env.MICROSERVICE_NAME }}"
          echo "üè∑Ô∏è  Image: cdg.ocir.io/${{ secrets.OCI_TENANCY_NAMESPACE }}/smartdish/${{ env.MICROSERVICE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "üåç Namespace: ${{ env.NAMESPACE }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üìÖ Date: $(date)"
          echo ""
          echo "=========================================="
          echo "üìä √âTAT DES RESSOURCES"
          echo "=========================================="
          kubectl get all -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üîó SERVICES EXPOS√âS"
          echo "=========================================="
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=${{ env.MICROSERVICE_NAME }}
          echo ""
          echo "=========================================="
          echo "üìù LOGS DES PODS (derni√®res 20 lignes)"
          echo "=========================================="
          kubectl logs -l app=${{ env.MICROSERVICE_NAME }} -n ${{ env.NAMESPACE }} --tail=20 || true
          echo ""
          echo "‚úÖ D√©ploiement CD termin√© avec succ√®s"

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur Kubernetes/OKE"
          else
            echo "‚ùå √âchec du d√©ploiement sur Kubernetes/OKE"
          fi